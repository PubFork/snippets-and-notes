// jenkins.io/doc/pipeline/steps
// <server_url>/job/<jobname>/pipeline-syntax/globals
// <server_url>/job/<jobname>/pipeline-syntax/html
pipeline {
  agent any

  parameters {
    string(name: 'BRANCH', defaultValue: 'master', description: 'GIT SCM branch from repository to clone/pull.')
    string(name: 'APP', description: 'The application for which to build and push an image.')
    string(name: 'REGISTRY', defaultValue: 'https://artifactory.company.com', description: 'The Docker Registry URL.')
    string(name: 'VERSION', defaultValue: "${env.BUILD_NUMBER.toInteger() + 1}", description: 'The version of the application for the Docker Image tag.')
  }
  environment {
    // set vars
    repo_imagename = "${params.REGISTRY}/${params.APP}"
  }

  stages {
    stage('Clone/Pull Application Code') {
      steps {
        // grab code
        checkout([
          $class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH}"]],
          doGenerateSubmoduleConfigurations: false,
          extensions: [[$class: 'RelativeTargetDirectory',
            relativeTargetDir: params.BRANCH]],
          submoduleCfg: [],
          userRemoteConfigs: [[url: "https://github.com:org/${params.APP}.git"]]])
      }
    }
    stage('Build Docker Image') {
      steps {
        dir(params.BRANCH) {
          script {
            try {
              // build docker image and store result to image object
              image = docker.build("${repo_imagename}:latest")
            }
            catch(Exception error) {
              print "Failure building Docker Image for ${params.APP} in branch ${params.BRANCH}:"
              throw error
            }
          }
        }
        print "Docker Image for ${params.APP} in branch ${params.BRANCH} created successfully."
      }
    }
    stage('Validate Docker Image') {
      steps {
        script {
          try {
            // superfluous tests for now
            image.inside {
              sh 'echo helloworld'
            }
            // robust tests with dgoss later
            // image.withRun {
              // goss.validate_docker()
            // }
          }
          catch(Exception error) {
            print "Failure validating Docker Image for ${params.APP} in branch ${params.BRANCH}."
            throw error
          }
        }
        print "Docker Image for ${params.APP} in branch ${params.BRANCH} validated successfully."
      }
    }
    stage('Store Docker Image in Artifactory') {
      // only do this stage if we are using artifactory
      when { expression { params.REGISTRY =~ /artifactory/ } }
      steps {
        script {
          // push docker image
          try {
            // initialize artifactory server object
            server = Artifactory.server(${params.REGISTRY}-${params.BRANCH})
            // alternative server inits with creds
            //server = Artifactory.newServer(url: 'artifactory-url', username: 'username', password: 'password')
            //server = Artifactory.newServer(url: 'artifactory-url', credentialsId: 'ccrreeddeennttiiaall')
            // initialize docker registry object
            artDocker = Artifactory.docker(server: server)
            // push docker image wtih latest and buildnum
            artDocker.push("${repo_imagename}:latest", "docker-${params.BRANCH}")
            image.tag("${repo_imagename}:${params.VERSION}")
            buildInfo = artDocker.push("${repo_imagename}:${params.VERSION}", "docker-${params.BRANCH}")
          }
          catch(Exception error) {
            print "Failure storing Docker Image for ${params.APP} in branch ${params.BRANCH} in ${params.REGISTRY}:"
            throw error
          }
          print "Docker Image with tags ${repo_imagename}:${params.VERSION} and ${repo_imagename}:latest stored successfully in Artifactory."
          // push docker repodigest and scan buildinfo for security issues
          try {
            // grab the repository digest for the image
            repoDigest = sh(returnStdout: true, script: "docker inspect -f \"{{.RepoDigests}}\" image.imageName()").trim()
            digest = repoDigest =~ /\[[a-z]+@sha256:(.*)\]/
            // add digest property to build info manifest artifact
            buildInfo.append(['repodigest' : digest[0]])
            // push build info manifest to artifactory
            server.publishBuildInfo(buildInfo)
            // scan image for vulnerabilities
            scanConfig = [
              'buildName' : buildInfo.name,
              'buildNumber' : buildInfo.number
            ]
            xrayScanBuild(scanConfig)
            // for purging older images
            //buildInfo.retention(maxBuilds: 10, deleteBuildArtifacts: true)
          }
          catch(Exception error) {
            print "Failure pushing RepoDigest for or Scanning Docker Image for ${params.APP} in branch ${params.BRANCH} in ${params.REGISTRY}:"
            throw error
          }
          print "Docker Image digest stored and artifact scanned successfully in Artifactory."
        }
      }
    }
    stage('Store Docker Image in Private Registry') {
      // only do this stage if we are using non-artifactory registry
      when { expression { params.REGISTRY !~ /artifactory/ } }
      steps {
        script {
          try {
            // push docker image with latest and buildnum
            // TODO: push digest in custom registry
            docker.withRegistry(${params.REGISTRY}-${params.BRANCH}, 'registry-credentials') {
              image.push()
              image.push("${repo_imagename}:${params.VERSION}")
            }
          }
          catch(Exception error) {
            print "Failure storing Docker Image for ${params.APP} in branch ${params.BRANCH} in ${params.REGISTRY}:"
            throw error
          }
        }
        print "Docker Image with tags ${repo_imagename}:${params.VERSION} and ${repo_imagename}:latest stored successfully in ${params.REGISTRY}."
      }
    }
  }
  post {
    success {
      print 'Job completed successfully.'
    }
    failure {
      print 'Job failed.'

      slackSend(channel: '#channel',
        color: 'warning',
        message: "Job failed for ${env.JOB_NAME}/${env.JOB_NAME} at ${env.JOB_URL}.")

      mail(to: 'root@localhost',
        subject: "Failure: ${env.BUILD_TAG}",
        body: "Job failed for ${env.JOB_NAME}/${env.JOB_NAME} at ${env.JOB_URL}.")
    }
  }
}
