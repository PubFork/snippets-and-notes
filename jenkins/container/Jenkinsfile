// jenkins.io/doc/pipeline/steps
// <server_url>/job/<jobname>/pipeline-syntax/globals
// <server_url>/job/<jobname>/pipeline-syntax/html
// need list of standards for making it more secure
// need list of standards for ensuring fewer vulnerabilities
// is hardening images a real thing or not? leverage dgoss
// periodic purging of old images from registry: artifactory-->local repository-->basic-->docker settings-->max unique tags
// periodic scanning of registry images with xray
// use artifactory intrinsic for promoting docker image to higher lifecycle registry?
// if prod store, then the version should really be based on git tag
pipeline {
  agent any

  parameters {
    string(name: 'BRANCH', defaultValue: 'master', description: 'GIT SCM branch from repository to clone/pull.')
    string(name: 'APP', description: 'The application for which to build and push an image.')
    string(name: 'REGISTRY', defaultValue: 'https://artifactory.company.com', description: 'The Docker Registry URL.')
  }

  stages {
    stage('Clone/Pull Application Code') {
      steps {
        // set vars
        repo_imagename = "${param.REGISTRY}/${params.APP}"
        // grab code
        checkout([
          $class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH}"]],
          doGenerateSubmoduleConfigurations: false,
          extensions: [[$class: 'RelativeTargetDirectory',
            relativeTargetDir: params.BRANCH]],
          submoduleCfg: [],
          userRemoteConfigs: [[url: "git@github_url:org/${params.APP}.git"]]])
      }
    }
    stage('Build Docker Image') {
      steps {
        dir(params.BRANCH) {
          script {
            try {
              // build docker image and store result to image object
              image = docker.build("${repo_imagename}:latest")
            }
            catch(Exception error) {
              print "Failure building Docker Image for ${params.APP} in branch ${params.BRANCH}:"
              throw error
            }
            print "Docker Image for ${params.APP} in branch ${params.BRANCH} created successfully."
          }
        }
      }
    }
    stage('Validate Docker Image') {
      steps {
        script {
          try {
            // superfluous tests for now
            image.inside {
              sh 'echo helloworld'
            }
            // robust tests with dgoss later
            // image.withRun {
              // goss.validate_docker()
            // }
          }
          catch(Exception error) {
            print "Failure validating Docker Image for ${params.APP} in branch ${params.BRANCH}."
            throw error
          }
        }
        print "Docker Image for ${params.APP} in branch ${params.BRANCH} validated successfully."
      }
    }
    stage('Store Docker Image in Artifactory') {
      // only do this stage if we are using artifactory
      when { expression { param.REGISTRY =~ /artifactory/ } }
      steps {
        script {
          try {
            // initialize artifactory server object
            server = Artifactory.server(${param.REGISTRY}-${param.BRANCH})
            // alternative server inits with creds
            //server = Artifactory.newServer(url: 'artifactory-url', username: 'username', password: 'password')
            //server = Artifactory.newServer(url: 'artifactory-url', credentialsId: 'ccrreeddeennttiiaall')
            // initialize docker registry object
            artDocker = Artifactory.docker(server: server)
            // push docker image wtih latest and buildnum
            artDocker.push("${repo_imagename}:latest", '<targetRepo>')
            image.tag("${repo_imagename}:${env.BUILD_NUMBER}")
            buildInfo = artDocker.push("${repo_imagename}:${env.BUILD_NUMBER}", '<targetRepo>')
            // scan image for vulnerabilities and push build info manifest
            xrayScanBuild(buildInfo)
            server.publishBuildInfo(buildInfo)
          }
          catch(Exception error) {
            print "Failure storing Docker Image for ${params.APP} in branch ${params.BRANCH} in ${param.REGISTRY}:"
            throw error
          }
        }
        print "Docker Image with tags ${repo_imagename}:${env.BUILD_NUMBER} and ${repo_imagename}:latest stored successfuly in Artifactory."
      }
    }
    stage('Store Docker Image in Private Registry') {
      // only do this stage if we are using non-artifactory registry
      when { expression { param.REGISTRY !~ /artifactory/ } }
      steps {
        script {
          try {
            // push docker image with latest and buildnum
            docker.withRegistry(${param.REGISTRY}-${param.BRANCH}, 'registry-credentials') {
              image.push()
              image.push("${repo_imagename}:${env.BUILD_NUMBER}")
            }
          }
          catch(Exception error) {
            print "Failure storing Docker Image for ${params.APP} in branch ${params.BRANCH} in ${param.REGISTRY}:"
            throw error
          }
        }
        print "Docker Image with tags ${repo_imagename}:${env.BUILD_NUMBER} and ${repo_imagename}:latest stored successfuly in ${param.REGISTRY}."
      }
    }
    stage('Capture Image Digest') {
      steps {
        script {
          // TODO: this needs a more stable method of digest gathering, this needs a better method of digest storage
          // grab the repository digest for the image
          repoDigest = sh(returnStdout: true, script: "docker inspect -f \"{{.RepoDigests}}\" image.imageName()").trim()
          digest = repoDigest =~ /\[[a-z]+@sha256:(.*)\]/
          // store the repository digest
          writeFile(file: "${params.APP}-digest.txt", text: digest[0])
          // TODO: alternatively, query artifactory with aql
        }
        print "Image Repository Digest is ${digest[0]}"
      }
    }
  }
  post {
    success {
      print 'Job completed successfully.'
    }
    failure {
      print 'Job failed.'

      slackSend(channel: '#channel',
        color: 'warning',
        message: "Job failed for ${env.JOB_NAME}/${env.JOB_NAME} at ${env.JOB_URL}.")

      mail(to: 'root@localhost',
        subject: "Failure: ${env.BUILD_TAG}",
        body: "Job failed for ${env.JOB_NAME}/${env.JOB_NAME} at ${env.JOB_URL}.")
    }
  }
}
