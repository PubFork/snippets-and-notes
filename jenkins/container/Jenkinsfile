// <server_url>/job/<jobname>/pipeline-syntax/globals
// <server_url>/job/<jobname>/pipeline-syntax/html
// docker is plugin so should not need script{} but reminder here just in case
// need list of standards for making it more secure
// need list of standards for ensuring fewer vulnerabilities
// is hardening images a real thing or not? leverage dgoss
// periodic purging of old images from registry (where would we do this?; retain only n number of recent versions; n is based on lifecycle env?)
pipeline {
  agent any

  parameters {
    string(name: 'BRANCH', defaultValue: 'master', description: 'GIT SCM branch from repository to clone/pull.')
    string(name: 'APP', description: 'The application for which to build and push an image.')
    string(name: 'REGISTRY', defaultValue: 'https://artifactory.company.com', description: 'The Docker Registry URL.')
  }

  tag_prefix = "${param.REGISTRY}/${params.APP}-${params.BRANCH}"

  stages {
    stage('Clone/Pull Application Code') {
      steps {
        checkout([
          $class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH}"]],
          doGenerateSubmoduleConfigurations: false,
          extensions: [[$class: 'RelativeTargetDirectory',
            relativeTargetDir: params.BRANCH]],
          submoduleCfg: [],
          userRemoteConfigs: [[url: "git@github_url:org/${params.APP}.git"]]])
      }
    }
    stage('Build Docker Image') {
      steps {
        dir(params.BRANCH) {
          try {
            image = docker.build("${tag_prefix}:latest")
          }
          catch(Exception error) {
            print "Failure building Docker Image for ${params.APP} in branch ${params.BRANCH}:"
            throw error
          }
          print "Docker Image for ${params.APP} in branch ${params.BRANCH} created successfully."
        }
      }
    }
    stage('Validate Docker Image') {
      steps {
        try {
          image.inside {
            // custom tests for now; dgoss later when I write support for it
          }
          // image.run? {
            // dgoss() // or do it this way but dgoss also runs container
          // }
        }
        catch(Exception error) {
          print "Failure validating Docker Image for ${params.APP} in branch ${params.BRANCH}."
          throw error
        }
        print "Docker Image for ${params.APP} in branch ${params.BRANCH} validated successfully."
      }
    }
    stage('Store Docker Image in Artifactory') {
      // if prod store, then the version should really be based on git tag
      when { expression { param.REGISTRY =~ /artifactory/ } }
      steps {
        try {
          server = Artifactory.server(param.REGISTRY)
          //server = Artifactory.newServer(url: 'artifactory-url', username: 'username', password: 'password')
          //server = Artifactory.newServer(url: 'artifactory-url', credentialsId: 'ccrreeddeennttiiaall')
          artDocker = Artifactory.docker(server: server)
          artDocker.push("${tag_prefix}:latest", '<targetRepo>')
          image.tag("${tag_prefix}:${env.BUILD_NUMBER}")
          artDocker.push("${tag_prefix}:${env.BUILD_NUMBER}", '<targetRepo>')
        }
        catch(Exception error) {
          print "Failure storing Docker Image for ${params.APP} in branch ${params.BRANCH} in ${param.REGISTRY}:"
          throw error
        }
        print "Docker Image with tags ${tag_prefix}:${env.BUILD_NUMBER} and ${tag_prefix}:latest stored successfuly in Artifactory."
      }
    }
    stage('Store Docker Image in Private Registry') {
      // if prod store, then the version should really be based on git tag
      when { expression { param.REGISTRY !~ /artifactory/ } }
      steps {
        try {
          docker.withRegistry(param.REGISTRY, 'registry-credentials') {
            image.push()
            image.push("${tag_prefix}:${env.BUILD_NUMBER}")
          }
        }
        catch(Exception error) {
          print "Failure storing Docker Image for ${params.APP} in branch ${params.BRANCH} in ${param.REGISTRY}:"
          throw error
        }
        print "Docker Image with tags ${tag_prefix}:${env.BUILD_NUMBER} and ${tag_prefix}:latest stored successfuly in registry."
      }
    }
    stage('Capture Image Digest') {
      steps {
        // this needs a more stable method of digest gathering, this needs a better method of digest storage
        repoDigest = sh(returnStdout: true, script: "docker inspect -f \"{{.RepoDigests}}\" image.imageName()").trim()
        [debian@sha256:4fcd8c0b6f5e3bd44a3e63be259fd0c038476d432953d449ef34aedf16def331]
        digest = repoDigest =~ /\[[a-z]+@sha256:(.*)\]/
        writeFile(file: "${params.APP}-digest.txt", text: digest[0])
        // alternatively, query artifactory with aql
      }
    }
    post {
      success {
        print 'Job completed successfully.'
      }
      failure {
        print 'Job failed.'

        slackSend(channel: '#channel',
          color: 'warning',
          message: "Job failed for ${env.JOB_NAME}/${env.JOB_NAME} at ${env.JOB_URL}.")

        mail(to: 'root@localhost',
          subject: "Failure: ${env.BUILD_TAG}",
          body: "Job failed for ${env.JOB_NAME}/${env.JOB_NAME} at ${env.JOB_URL}.")
      }
    }
  }
}
