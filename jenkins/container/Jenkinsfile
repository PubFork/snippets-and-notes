// <server_url>/job/<jobname>/pipeline-syntax/globals
// <server_url>/job/<jobname>/pipeline-syntax/html
// docker is plugin so should not need script{} but reminder here just in case
// need list of standards for making it more secure
// need list of standards for ensuring fewer vulnerabilities
// is hardening images a real thing or not? leverage dgoss
// periodic purging of old images from registry (where would we do this?; retain only n number of recent versions; n is based on lifecycle env?)
pipeline {
  agent any

  parameters {
    string(name: 'BRANCH', defaultValue: 'master', description: 'GIT SCM branch from repository to clone/pull.')
    string(name: 'APP', description: 'The application for which to build and push an image.')
    booleanParam(name: 'ARTIFACTORY', defaultValue: true, description: 'Use Artifactory as the Docker Registry.')
  }

  stages {
    stage('Clone/Pull Application Code') {
      steps {
        checkout([
          $class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH}"]],
          doGenerateSubmoduleConfigurations: false,
          extensions: [[$class: 'RelativeTargetDirectory',
            relativeTargetDir: params.BRANCH]],
          submoduleCfg: [],
          userRemoteConfigs: [[url: "git@github_url:org/${params.APP}.git"]]])
      }
    }
    stage('Build Docker Image') {
      steps {
        dir(params.BRANCH) {
          try {
            image = docker.build("${params.APP}/${params.BRANCH}")
          }
          catch(Exception error) {
            print "Failure building Docker Image for ${params.APP} in branch ${params.BRANCH}:"
            throw error
          }
          print "Docker Image for ${params.APP} in branch ${params.BRANCH} created successfully."
        }
      }
    }
    stage('Validate Docker Image') {
      steps {
        try {
          image.inside {
            // custom tests for now; dgoss later when I write support for it
          }
          // image.run? {
            // dgoss() // or do it this way but dgoss also runs container
          // }
        }
        catch(Exception error) {
          print "Failure validating Docker Image for ${params.APP} in branch ${params.BRANCH}."
          throw error
        }
        print "Docker Image for ${params.APP} in branch ${params.BRANCH} validated successfully."
      }
    }
    stage('Store Docker Image in Artifactory') {
      // also digest capture; end goal is to ensure immutability and lack of image tampering
      // if prod store, then the version should really be based on git tag
      when { expression { param.ARTIFACTORY == true } }
      steps {
        try {
          // initialize artifactory instance
          server = Artifactory.server '<ArtifactoryServerID>'
          // initialize artifactory docker server instance
          artDocker = Artifactory.docker(server: server)
          // store image in artifactory
          artDocker.push("<artifactoryDockerRegistry>/${params.APP}-${params.BRANCH}:${env.BUILD_NUMBER}", '<targetRepo>')
          artDocker.push("<artifactoryDockerRegistry>/${params.APP}-${params.BRANCH}:latest", '<targetRepo>')
        }
        catch(Exception error) {
          print "Failure storing Docker Image for ${params.APP} in branch ${params.BRANCH} in Artifactory:"
          throw error
        }
        print "Docker Image with tags ${params.APP}/${params.BRANCH}:${env.BUILD_NUMBER} and ${params.APP}/${params.BRANCH}:latest// also digest capture; end goal is to ensure immutability and lack of image tampering stored successfuly in Artifactory."
      }
    }
    stage('Store Docker Image in Private Registry') {
      // also digest capture; end goal is to ensure immutability and lack of image tampering
      // if prod store, then the version should really be based on git tag
      when { expression { param.ARTIFACTORY == false } }
      steps {
        try {
          docker.withRegistry('registry_url', 'registry-credentials') {
            image.push("repo/${params.APP}-${params.BRANCH}:${env.BUILD_NUMBER}")
            image.push("repo/${params.APP}-${params.BRANCH}:latest")
          }
        }
        catch(Exception error) {
          print "Failure storing Docker Image for ${params.APP} in branch ${params.BRANCH} in a custom registry:"
          throw error
        }
        print "Docker Image with tags ${params.APP}-${params.BRANCH}:${env.BUILD_NUMBER} and ${params.APP}-${params.BRANCH}:latest stored successfuly in registry."
      }
    }
    post {
      success {
        print 'Job completed successfully.'
      }
      failure {
        print 'Job failed.'

        slackSend(channel: '#channel',
          color: 'warning',
          message: "Job failed for ${env.JOB_NAME}/${env.JOB_NAME} at ${env.JOB_URL}.")

        mail(to: 'root@localhost',
          subject: "Failure: ${env.BUILD_TAG}",
          body: "Job failed for ${env.JOB_NAME}/${env.JOB_NAME} at ${env.JOB_URL}.")
      }
    }
  }
}
